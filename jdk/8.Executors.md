## Executors

### newFixedThreadPool
&emsp;固定线程数量，内部采用LinkedBlockingQueue缓存任务；  

### newSingleThreadExecutor
&emsp;同FixedThreadPool实现一样，只是将线程数设置为1；内部采用LinkedBlockingQueue缓存任务； 

### newCachedThreadPool
&emsp;每个任务对应一个线程，内部采用SynchronousQueue实现任务的缓存；

### newSingleThreadScheduledExecutor

### newScheduledThreadPool

### newWorkStealingPool
&emsp;工作窃取线程池，内部采用ForkJoinPool来实现工作任务的窃取；  
&emsp; ThreadPoolExecutor还在用单个队列存放任务时，ForkJoinPool已经分配了与线程数相等的队列，当有任务加入线程池时，会被平均分配到对应的队列上，各线程进行正常工作，当有线程提前完成时，会从队列的末端“窃取”其他线程未执行完的任务，当任务量特别大时，CPU多的计算机会表现出更好的性能。  

	volatile WorkQueue[] workQueues;     // main registry
	

### SynchronousQueue
&emsp;Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。  
&emsp;根据公平策略，如果是公平的，则内部使用TransferQueue来实现，达到FIFO的效果；否则使用TransferStack

