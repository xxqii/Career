## Synchronized
### 原理
&emsp; synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时可以保证共享变量的内存可见性。  
&emsp; Java中每一个对象都可以作为锁：  
1. 普通同步方法，锁是当前实例对象
2. 静态同步方法，锁是当前类的class对象
3. 同步方法块，锁是括号里面的对象  
&emsp;当一个线程访问同步代码块时，它首先需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁。  
* 同步代码块：使用monitorenter和monitorexit指令实现的；
* 同步方法：依靠方法修饰符上的ACC_SYNCHRONIZED实现；

### Java对象头
&emsp; synchronized使用的锁是存在java对象头里的。Hotspot虚拟机的对象头主要包括两部分数据：MarkWork、KlassPointer。  
* KlassPointer：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；
* MarkWord：用于存储对象自身运行时的数据，它是实现轻量级锁和偏向锁的关键；  
&emsp;MarkWord用于存储自身运行时的数据，例如：HashCode、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
### monitor
&emsp;我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。  
&emsp;与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。  

### 锁优化
&emsp;JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁的开销；  
&emsp;锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。  

1 自旋锁
&emsp;线程的阻塞和唤醒需要cpu从用户态切换为和心态，频繁的阻塞和唤醒对cpu来说是一件负担很重的工作，会给系统的性能带来很大的压力。
在很多应用里面，对象锁的状态只会持续很短一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程是非常不值得的。所以引入了自旋锁。
&emsp;自旋锁不能替代阻塞，虽然可以避免线程切换带来的开销，但是它占用了处理器的时间，如果持有的锁很快就释放了，会带来性能的提升，如果锁的时间比较长，反而会带来性能的浪费；  
&emsp;自旋锁在jdk1.4.2中引入，默认关闭，可以通过-XX:+UseSpinning开启；在jdk1.6中默认开启，可以通过参数-XX:PreBlockSpin设置自选的次数，默认10次。

2 适应性自旋锁
&emsp;JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。
&emsp;有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。  

3 锁消除  
&emsp;为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。  
&emsp;我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：  

	public void vectorTest(){  
		Vector<String> vector = new Vector<String>();  
		for(int i = 0 ; i < 10 ; i++){   
			vector.add(i + "");  
		}  
		System.out.println(vector);  
	}  
	
&emsp;在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。  

4 锁粗化
&emsp;我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。  
&emsp;锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。  

5 轻量级锁
&emsp; 引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：  
* 获取锁

1 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；  
2 JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；  
3 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；  

* 释放锁
轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：

1 取出在获取轻量级锁保存在Displaced Mark Word中的数据；  
2 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；  
3 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。  

&emsp;总结：判断当前对象是否无锁(hashcode + 0 + 01)，如果没有锁，在当前线程的栈帧上开辟空间（LockRecord），将MarkWord的值拷贝到LockRecord；通过CAS修改MarkWord为LockRecord的指针，
如果修改成功，则获取轻量级锁成功，将所标志位修改为00（00代表轻量级锁）；如果失败，先判断MarkWord是否指向当前栈帧，如果是说明已经获得了对象的锁（重复获取锁的情况），
如果失败说明锁被别的线程抢占了，修改锁标记位为10（10代码重量级锁），锁膨胀为重量级锁，后面的线程阻塞。  

6 偏向锁  
&emsp; 为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：  
* 锁获取
1 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；  
2 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；  
3 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；  
4 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；  
5 执行同步代码块  
* 释放锁
&emsp;偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：  
1 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；
2 撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；