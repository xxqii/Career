## 缓存击穿
&emsp; 缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库异常。这个我们在实际项目就遇到了，有些抢购活动、秒杀活动的接口API被大量的恶意用户刷，导致短时间内数据库c超时了，好在数据库是读写分离，同时也有进行接口限流，hold住了。  
* 使用互斥锁
&emsp; 即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了  
&emsp; 缺点：锁机制使得逻辑的复杂度增加，吞吐量也降低了，有点治标不治本。  
* 限流与熔断、降级
&emsp; 重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。  
* 布隆过滤器
&emsp; bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，  
* 对空结果进行缓存（过期时间较短）
* 异步队列；
## 缓存雪崩
&emsp; 缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。  
* 加锁
* 多级缓存；备用缓存：不加过期时间；
* 缓存超时时间加一个随机的时间长度，避免同一时刻大量缓存过期；
* 通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存
* 异步队列；